# 문제 제목: [34079 좋아하는 다이아몬드가 안경을 깜빡했다](https://www.acmicpc.net/problem/34079)
- **플랫폼**: 백준
- **난이도**: 7/10
- **풀이 유형**: BFS / 역추적

---

## 1. 문제 요약
- 문제 핵심:
  - 그래프에서 그래프에서 1번 노드에서 n번 노드로 가는 모든 최단경로가 공통으로 거치는 노드를 하나 출력합니다.
- 입력/출력 조건: 여러개가 정답이 될 수 있으면 그중에 한개를 출력하고, 해당하는 노드가 없다면 1을 출력합니다.
- 제한 조건: $1\leq N\leq 200,000, N-1\leq M \leq \min(\frac{N(N-1)}{2} , 300,000)$

---

## 2. 접근 아이디어
- 자력 풀이 시도:
  - bfs+역추적으로 최단경로를 구하고 공통된 노드를 찾는다. -> 최단경로 수가 너무커 시간초과가 날게 뻔했다.
  - 역추적 dict에서 가장 많은 부모노드를 가진 것이 무조건 지나는 노드이다. -> 반례를 직접 찾았다
  - bfs를 1번노드와 n번노드에서 수행한다. -> 그후 연결고리를 찾는데 실패했다.
- 막혔던 포인트:
  - 너무 역추적에 집중하여 경로들과 노드에 연관성을 찾지 못하였다.
- 답지 참고 후:
    - 임의의 최단경로에 포함되는 노드$u$의 $d(1,u)$가 유일하다면 해당 노드는 모든 최단경로가 지나가는 노드이다.
      1. bfs를 돌릴때 parent 해시맵을 부모를 저장한다.
      2. n번 노드부터 parent을 사용하여 역추적을 진행하면 최단경로가 지나가는 노드 집합$U$를 얻을 수 있다.
      3. $U$를 순회하며 $d(1,u)$가 유일한지 확인하여 정답을 구한다.
    -  bfs두번과 $d(1,n)=d(1,u)+d(u,n)$을 사용하여 다음을 구한다.
       1. 1번 노드와 n번노드에서 bfs를 통하여 최단거리를 구한다.
       2. 1번 노드에서 시작한 최단거리 배열이 $d_1$, n번 노드에서 시작한 최단거리 배열이 $d_n$이라고 할때, $d_1[u]+d_n[u]=d_1[n]$ 인 노드 $u$들을 전체를 $U$라고 하자. $U$집합은 역추적을 이용한 풀이와 같이 최단경로 위 노드 집합이 된다.
       3. 이후 위의 3번과 똑같이 정답을 구할 수 있다.

---

## 3. 코드 정리
[정답 코드(역추적)](./answer1.py) <br>
[정답 코드(bfs2번)](./answer2.py)

---

## 4. 시간/공간 복잡도

* 시간: $O(N+M)$
* 공간: $O(N+M)$

---

## 5. 배운 점 / 실수

* bfs의 역추적을 응용하는 방법에 대해 알게되었다.
* 최단거리의 기본개념을 어떻게 적용해야 할지 아이디어를 주는 문제가 되었다.
